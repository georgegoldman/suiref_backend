{"version":3,"file":"index.esm.js","sources":["../node_modules/tslib/tslib.es6.js","../src/jws/toString.ts","../src/jwa/sign.ts","../src/errors/baseDjwtError.ts","../src/errors/jwt.ts","../src/errors/jws.ts","../src/errors/jwa.ts","../src/jwa/verify.ts","../src/utils/isHexString.ts","../src/jws/sign.ts","../src/jws/verify.ts","../src/schemas/signSchemas.ts","../src/schemas/verifySchemas.ts","../src/decode.ts","../src/utils/timespan.ts","../src/verify.ts","../src/sign.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n","import { Buffer } from \"buffer\";\n\nexport function toString(obj: object): string {\n  if (typeof obj === \"string\") return obj;\n  if (typeof obj === \"number\" || Buffer.isBuffer(obj)) return obj.toString();\n  return JSON.stringify(obj);\n}\n","import type { Signer } from \"../types\";\n\nexport async function signPayload(\n  payload: string,\n  signer: Signer\n): Promise<string> {\n  return signer(payload);\n}\n","\nexport interface DjwtError extends Error {\n\treadonly name: string;\n\treadonly code?: number;\n\treadonly stack?: string;\n}\n\nexport abstract class BaseDjwtError extends Error implements DjwtError {\n\tpublic override readonly name: string;\n\tpublic readonly code?: number;\n\tpublic override stack: string | undefined;\n\tpublic innerError: Error | Error[] | undefined;\n\n\tpublic constructor(msg?: string, innerError: Error | Error[] = new Error(\"dJWT Error\")) {\n\t\tsuper(msg);\n\t\tthis.innerError = innerError;\n\t\tthis.name = this.constructor.name;\n\t\tif (typeof Error.captureStackTrace === 'function') {\n\t\t\tError.captureStackTrace(new.target.constructor);\n\t\t} else {\n\t\t\tthis.stack = new Error().stack;\n\t\t}\n\t}\n\n\tpublic static convertToString(value: Error) {\n\t\tif (value === null || value === undefined) return 'undefined';\n\n\t\tconst result = JSON.stringify(value);\n\t\treturn result;\n\t}\n\n\tpublic toJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tcode: this.code,\n\t\t\tmessage: this.message,\n\t\t\tinnerError: this.innerError,\n\t\t};\n\t}\n}\n","import { BaseDjwtError } from \"./baseDjwtError\";\n\nexport class TokenExpiredError extends BaseDjwtError {\n  public expiredAt: number;\n\n  public constructor(message: string, expiredAt: number) {\n    super(message);\n    this.expiredAt = expiredAt;\n  }\n}\n\nexport class NotBeforeError extends BaseDjwtError {\n  public date: number;\n\n  public constructor(message: string, date: number) {\n    super(message);\n    this.date = date;\n  }\n}\n\nexport class TimespanDecodingError extends BaseDjwtError {\n  public time: number | string;\n\n  public constructor(message: string, date: number | string) {\n    super(message);\n    this.time = date;\n  }\n}\n\nexport class VerificationError extends BaseDjwtError {\n  public constructor(message: string) {\n    super(message);\n  }\n}\nexport class OptionsVerificationError extends BaseDjwtError {\n  public incorrectValue: string | number;\n  public expectedValue: string | number;\n\n  public constructor(\n    message: string,\n    incorrectValue: string | number,\n    expectedValue: string | number\n  ) {\n    super(\n      message + ` ${incorrectValue} is not equal to expected: ${expectedValue}`\n    );\n    this.incorrectValue = incorrectValue;\n    this.expectedValue = expectedValue;\n  }\n}\n\nexport class InvalidPayloadError extends BaseDjwtError {\n  public constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class InvalidSignOptionsError extends BaseDjwtError {\n  public payloadValue?: string;\n  public optionsValue?: string;\n\n  public constructor(\n    message: string,\n    payloadVal?: string,\n    optionsVal?: string\n  ) {\n    super(message);\n    this.payloadValue = payloadVal;\n    this.optionsValue = optionsVal;\n  }\n}\n","import { BaseDjwtError } from './baseDjwtError';\n\nexport class JwsDecodingError extends BaseDjwtError {\n  public jwt?: string;\n\n  public constructor(message: string, token?: string) {\n    super(message);\n    this.jwt = token;\n  }\n}\n\nexport class JwsEncodingError extends BaseDjwtError {\n  public jwt?: string;\n\n  public constructor(message: string, token?: string) {\n    super(\n      message + ` ${token}`\n    );\n  this.jwt = token;\n  }\n}\n\nexport class JwsVerifyError extends BaseDjwtError {\n\n\tpublic constructor(message : string) {\n\t\tsuper(message);\n\t}\n}","import { BaseDjwtError } from './baseDjwtError';\n\nexport class JwaVerifyError extends BaseDjwtError {\n  public argument: any;\n  public constructor(message: string, arg: any) {\n    super(message);\n    this.argument = arg;\n  }\n}\n\nexport class JwaAddressIncorrectError extends BaseDjwtError {\t\n\tpublic expectedAddress? : string; \n\tpublic returnedAddress? : string; \n\t\n\tpublic constructor(expectedAddress: string, returnedAddress: string) {\n\t\tsuper(`Expected address : ${expectedAddress}, does not match with Returned Address: ${returnedAddress}`);\n\t\tthis.expectedAddress = expectedAddress;\n\t\tthis.returnedAddress = returnedAddress;\n\t}\n}","import type { Verifier } from \"../types\";\nimport { JwaVerifyError, JwaAddressIncorrectError } from \"../errors\";\n\nexport async function jwaVerify(\n  verifier: Verifier,\n  payload: string,\n  signature: string,\n  address: string\n): Promise<boolean> {\n  const result = await verifier(payload, signature, address);\n  switch (typeof result) {\n    case \"boolean\": {\n      return result as boolean;\n    }\n    case \"string\": {\n      if (result === address) return true;\n      else throw new JwaAddressIncorrectError(address, result);\n    }\n    default:\n      throw new JwaVerifyError(\n        \"verifier() does not return boolean or string\",\n        result\n      );\n  }\n}\n","\nexport function isHexString(str: string): { str: string, isHex: boolean } {\n    if (str.slice(0, 2) === '0x') {\n        str = str.split('0x')[1];\n    }\n    const regExp = /^[0-9a-fA-F]+$/;\n\n    if (regExp.test(str))\n        return { str, isHex: true }\n    \n    return { str, isHex: false };\n}\n","import { Buffer } from \"buffer\";\nimport { toString } from \"./toString\";\nimport { signPayload } from \"../jwa\";\nimport type { Payload, Header, Signer } from \"../types\";\nimport { isHexString } from \"../utils/isHexString\";\nimport { JwsEncodingError } from \"../errors/jws\"\n\nfunction base64url(string: & string, encoding: BufferEncoding): string {\n\n  if (encoding === 'hex') {\n    let { str, isHex } = isHexString(string);\n    if (!isHex)\n      throw new JwsEncodingError('Non-Hexstring provided with hex encoding', string);\n    string = str;\n  }\n\n  return Buffer.from(string, encoding)\n    .toString(\"base64\")\n    .replace(/=/g, \"\")\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\");\n}\n\nfunction jwsSecuredInput(\n  header: Header,\n  payload: Payload,\n): string {\n  let encodedHeader = base64url(toString(header), 'utf-8');\n  let encodedPayload = base64url(toString(payload), 'utf-8');\n  return `${encodedHeader}.${encodedPayload}`;\n}\n\nexport async function signJws(\n  header: Header,\n  payload: Payload,\n  signer: Signer,\n  sigEncoding: BufferEncoding\n): Promise<string> {\n  let securedInput = jwsSecuredInput(header, payload);\n  let signature = await signPayload(securedInput, signer);\n  return `${securedInput}.${base64url(signature, sigEncoding)}`\n}\n","import { Buffer } from \"buffer\";\nimport { jwaVerify } from \"../jwa\";\nimport { JwsDecodingError } from \"../errors\";\n\nimport type { Token, Verifier, Header, Payload } from \"../types\";\n\nconst JWS_REGEX = /^[a-zA-Z0-9\\-_]+?\\.[a-zA-Z0-9\\-_]+?\\.([a-zA-Z0-9\\-_]+)?$/;\n\nfunction isObject(thing: any): boolean {\n  return Object.prototype.toString.call(thing) === \"[object Object]\";\n}\n\nfunction safeJsonParse(thing: any) {\n  if (isObject(thing)) return thing;\n  try {\n    return JSON.parse(thing);\n  } catch (e) {\n    return undefined;\n  }\n}\n\nfunction headerFromJWS(jwsSig: string): Header {\n  let encodedHeader = jwsSig.split(\".\", 1)[0];\n\n  if (encodedHeader)\n    return safeJsonParse(\n      Buffer.from(encodedHeader, \"base64\").toString(\"binary\")\n    );\n  else throw new JwsDecodingError(\"Error decoding jws from this jwt\", jwsSig);\n}\n\nfunction securedInputFromJWS(jwsSig: string): string {\n  return jwsSig.split(\".\", 2).join(\".\");\n}\n\nfunction signatureFromJWS(jwsSig: string, sigEncoding: BufferEncoding = 'hex'): string {\n  const sig = jwsSig.split(\".\")[2];\n\n  if (sig){\n    const signature = Buffer.from(sig, \"base64\").toString(sigEncoding);\n    const returnValue = sigEncoding === 'hex' ? '0x' + signature : signature;\n\n    return returnValue;\n  }\n  throw new JwsDecodingError(\"Signature not present in token\", jwsSig);\n}\n\nfunction payloadFromJWS(jwsSig: string): string {\n  let payload = jwsSig.split(\".\")[1];\n\n  if (payload) return Buffer.from(payload, \"base64\").toString('utf-8');\n  else throw new JwsDecodingError(\"Error decoding jws\", jwsSig);\n}\n\nexport function isValidJws(string: string): boolean {\n  return JWS_REGEX.test(string) && !!headerFromJWS(string);\n}\n\nexport async function jwsVerify(\n  verifier: Verifier,\n  jwsSig: string,\n  address: string,\n  sigEncoding?: BufferEncoding\n): Promise<boolean> {\n  let signature = signatureFromJWS(jwsSig, sigEncoding);\n  let securedInput = securedInputFromJWS(jwsSig);\n  return jwaVerify(verifier, securedInput, signature, address);\n}\n\nexport function decodeJws(\n  jwsSig: string,\n  sigEncoding?: BufferEncoding\n): Token {\n  if (!isValidJws(jwsSig))\n    throw new JwsDecodingError(\"JWT doesn't pass regex\", jwsSig);\n\n  let header = headerFromJWS(jwsSig);\n  if (!header) throw new JwsDecodingError(\"JWT doesn't contain header\", jwsSig);\n\n  let payload = JSON.parse(payloadFromJWS(jwsSig)) as Payload;\n  return {\n    header: header,\n    payload: payload,\n    signature: signatureFromJWS(jwsSig, sigEncoding),\n  };\n}\n","import { z } from \"zod\";\n\nexport const payloadSchema = z.object({\n  iss: z\n    .string({ invalid_type_error: \"Issuer (iss) claim has to be a string\" })\n    .min(1, \"Issuer (iss) claim has to be non-empty.\"),\n  nonce: z\n    .number({ invalid_type_error: \"nonce has to be a number\" })\n    .positive(\"A nonce > 0 has to be provided.\"),\n  exp: z\n    .number({\n      invalid_type_error: \"Expiration Time (exp) claim has to be a number\",\n    })\n    .positive(\n      \"A positive number as Expiration Time (exp) claim has to be provided.\"\n    ),\n  iat: z\n    .number()\n    .positive(\n      \"Issued At (iat) claim, if provided, has to be a positive number.\"\n    )\n    .optional(),\n  nbf: z\n    .number()\n    .positive(\n      \"Not Before (nbf) claim, if provided, has to be a positive number.\"\n    )\n    .optional(),\n  sub: z\n    .string()\n    .min(1, \"Subject (sub) claim, if provided, has to be a non-empty string.\")\n    .optional(),\n  jti: z\n    .string()\n    .min(1, \"JWT ID (jti) claim, if provided, has to be a non-empty string.\")\n    .optional(),\n  aud: z\n    .union([\n      z.string().min(1,),\n      z\n        .array(z.string())\n        .min(1,\n          \"Audience (aud) claim, if provided, has to be a non-empty string or an array of string.\"\n        ),\n    ])\n    .optional(),\n}).strict();\n\nexport const headerSchema = z.object({\n  alg: z.string().min(1, \"header.alg has to be provided.\")\n}).strict();\n\nexport const signOptionsSchema = z.object({\n  algorithm: z\n    .string({ invalid_type_error: \"Algorithm has to be a string\" })\n    .min(1, \"options.algorithm has to be provided.\"),\n  header: headerSchema,\n  sigEncoding: z\n    .string()\n    .min(1, \"sigEncoding, if provided, has to be a non-empty string.\"),\n  noTimestamp: z.boolean(),\n  expiresIn: z\n    .union([\n      z.number().positive(),\n      z\n        .string()\n        .min(1,\n          'options.expiresIn, if provided, has to be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'\n        ),\n    ]),\n  notBefore: z\n    .union([\n      z.number().positive(),\n      z\n        .string()\n        .min(1,\n          'options.notBefore, if provided, has to be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'\n        ),\n    ]),\n}).partial().strict();\n","import { z } from \"zod\";\n\nexport const verifyOptionsSchema = z\n  .object({\n    audience: z.union([\n      z.string().min(1,),\n      z\n        .array(z.string())\n        .min(1,\n          \"options.audience, if provided, has to be a non-empty string or an array of string.\"\n        ),\n    ]),\n    issuer: z.union([\n      z.string().min(1,),\n      z\n        .array(z.string())\n        .min(1,\n          \"options.issuer, if provided, has to be a non-empty string or an array of string.\"\n        ),\n    ]),\n    subject: z\n      .string()\n      .min(1, \"options.subject, if provided, has to be a non-empty string.\"),\n    jwtid: z\n      .string()\n      .min(1, \"options.jwtid, if provided, has to be a non-empty string.\"),\n    clockTimestamp: z\n      .number()\n      .positive(\n        \"options.clockTimestamp, if provided, has to be a positive number.\"\n      ),\n    nonce: z\n      .number({\n        invalid_type_error: \"options.nonce, if provided, has to be a number\",\n      })\n      .positive(\"options.nonce, if provided, has to be a positive integer\"),\n    ignoreNotBefore: z.boolean({\n      invalid_type_error:\n        \"options.ignoreNotBefore, if provided, has to be a boolean\",\n    }),\n    clockTolerance: z\n      .number()\n      .positive(\n        \"options.clockTolerance, if provided, has to be a positive number.\"\n      ),\n    ignoreExpiration: z.boolean({\n      invalid_type_error:\n        \"options.ignoreExpiration, if provided, has to be a boolean.\",\n    }),\n    maxAge: z\n      .number()\n      .positive(\"options.maxAge, if provided, has to be a positive number.\"),\n    complete: z.boolean({\n      invalid_type_error: \"options.complete, if provided, has to be a boolean\"\n    }),\n    sigEncoding: z\n      .string()\n      .min(1, \"sigEncoding, if provided, has to be a non-empty string.\"),\n    algorithm: z\n      .string()\n      .min(1,\n        \"options.algorithm, if provided, has to be a non-empty string.\"\n      ),\n  })\n  .partial()\n  .strict();\n\n\nexport const decodeOptionsSchema = z\n  .object({\n    complete: z.boolean({\n      invalid_type_error: \"options.complete, if provided, has to be a boolean\"\n    }),\n    sigEncoding: z\n      .string()\n      .min(1, \"sigEncoding, if provided, has to be a non-empty string.\")\n  })\n  .partial()\n  .strict();","import { decodeJws } from \"./jws\";\nimport { TokenOrPayload, DecodeOptions } from \"./types\";\nimport { VerificationError } from \"./errors\";\nimport { decodeOptionsSchema } from \"./schemas\";\n\nexport function decodeJWT(\n  jwtString: string,\n  options?: Partial<DecodeOptions>\n): TokenOrPayload {\n  options = Object.assign({}, options);\n  \n  const optionsParseResult = decodeOptionsSchema.safeParse(options);\n  if (!optionsParseResult.success) {\n    throw new VerificationError(\n      JSON.parse(optionsParseResult.error.message)[0].message\n    );\n  }\n  \n  const decoded = decodeJws(jwtString, options.sigEncoding);\n  const payload = decoded.payload;\n  if (options.complete)\n    return {\n      header: decoded.header,\n      payload: payload,\n      signature: decoded.signature,\n    };\n  else return payload;\n}\n","import ms from \"ms\";\nimport { TimespanDecodingError } from \"../errors\";\n\nexport function timespan(time: string | number, timestamp: number): number {\n  if (typeof time === \"string\") {\n    let milliseconds: any = ms(time);\n    if (typeof milliseconds === \"undefined\") {\n      throw new TimespanDecodingError(\"Error while decoding time\", time);\n    }\n    return Math.floor(timestamp + milliseconds / 1000);\n  } else if (typeof time === \"number\") {\n    return timestamp + time;\n  } else {\n    throw new TimespanDecodingError(\n      \"Time is not of the tpye number or string\",\n      time\n    );\n  }\n}\n","import { z } from \"zod\";\n\nimport { decodeJWT } from \"./decode\";\nimport { timespan } from \"./utils\";\nimport { jwsVerify } from \"./jws\";\nimport {\n  VerificationError,\n  InvalidPayloadError,\n  TokenExpiredError,\n  NotBeforeError,\n  OptionsVerificationError,\n} from \"./errors\";\nimport { verifyOptionsSchema, headerSchema, payloadSchema } from \"./schemas\";\n\nimport type { VerifyOptions, Verifier, TokenOrPayload } from \"./types\";\n\nexport async function verifyJWT(\n  jwtString: string,\n  verifier: Verifier,\n  options?: Partial<VerifyOptions>\n): Promise<TokenOrPayload> {\n  //clone this object since we are going to mutate it.\n  options = Object.assign({}, options);\n\n  const optionsParseResult = verifyOptionsSchema.safeParse(options);\n  if (!optionsParseResult.success) {\n    throw new VerificationError(\n      JSON.parse(optionsParseResult.error.message)[0].message\n    );\n  }\n\n  jwtString = z\n    .string({\n      invalid_type_error: \"jwtString must be provided\",\n    })\n    .min(1, \"jwtString must be non-empty\")\n    .parse(jwtString);\n\n  if (jwtString.split(\".\").length !== 3) {\n    throw new VerificationError(\"jwt malformed\");\n  }\n\n  const clockTimestamp =\n    options.clockTimestamp || Math.floor(Date.now() / 1000);\n\n  const decodedToken = decodeJWT(jwtString, {\n    complete: true,\n    sigEncoding: options.sigEncoding\n  });\n\n  if (!decodedToken) {\n    throw new VerificationError(\"Invalid token\");\n  }\n\n  if (!decodedToken.header) {\n    throw new VerificationError(\n      \"Invalid token decoding, header not present in decoded token\"\n    );\n  }\n\n  if (!decodedToken.payload) {\n    throw new VerificationError(\n      \"Invalid token decoding, payload not present in decoded token\"\n    );\n  }\n\n  if (!decodedToken.signature) {\n    throw new VerificationError(\n      \"Invalid token decoding, signature not present in decoded token\"\n    );\n  }\n\n  const header = decodedToken.header;\n  const headerParseResult = headerSchema.safeParse(header);\n  if (!headerParseResult.success) {\n    throw new VerificationError(\n      JSON.parse(headerParseResult.error.message)[0].message\n    );\n  }\n\n  const payload = decodedToken.payload;\n  const payloadParseResult = payloadSchema.safeParse(payload);\n  if (!payloadParseResult.success) {\n    throw new InvalidPayloadError(\n      JSON.parse(payloadParseResult.error.message)[0].message\n    );\n  }\n\n  if (options.algorithm) {\n    if (options.algorithm !== header.alg)\n      throw new OptionsVerificationError(\n        \"Header.alg is incorrect.\",\n        header.alg,\n        options.algorithm\n      );\n  }\n\n  if (payload.nbf !== undefined && !options.ignoreNotBefore) {\n    if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {\n      throw new NotBeforeError(\"jwt not active\", payload.nbf);\n    }\n  }\n\n  if (payload.exp !== undefined && !options.ignoreExpiration) {\n    if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {\n      throw new TokenExpiredError(\"jwt expired\", payload.exp);\n    }\n  }\n\n  if (options.audience) {\n    if (payload.aud === undefined)\n      throw new VerificationError(\n        \"options.audience is present but payload.aud is not\"\n      );\n\n    const audiences = Array.isArray(options.audience)\n      ? options.audience\n      : [options.audience];\n    const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\n\n    const match = target.some(function (targetAudience) {\n      return audiences.some(function (audience: any) {\n        return audience instanceof RegExp\n          ? audience.test(targetAudience)\n          : audience === targetAudience;\n      });\n    });\n\n    if (!match) {\n      throw new OptionsVerificationError(\n        \"JWT audience is incorrect.\",\n        target.join(\" or \"),\n        audiences.join(\" or \")\n      );\n    }\n  }\n\n  if (options.issuer) {\n    const invalid_issuer =\n      payload.iss !== options.issuer ||\n      (Array.isArray(options.issuer) &&\n        options.issuer.indexOf(payload.iss) === -1);\n\n    if (invalid_issuer) {\n      throw new OptionsVerificationError(\n        \"JWT issuer invalid.\",\n        payload.iss,\n        Array.isArray(options.issuer)\n          ? options.issuer.join(\" or \")\n          : options.issuer\n      );\n    }\n  }\n\n  if (options.subject) {\n    if (payload.sub !== options.subject) {\n      throw new OptionsVerificationError(\n        \"JWT subject invalid.\",\n        payload.sub ? payload.sub : \"undefined\",\n        options.subject\n      );\n    }\n  }\n\n  if (options.jwtid) {\n    if (payload.jti !== options.jwtid) {\n      throw new OptionsVerificationError(\n        \"JWT ID invalid.\",\n        payload.jti ? payload.jti : \"undefined\",\n        options.jwtid\n      );\n    }\n  }\n\n  if (options.nonce) {\n    if (payload.nonce !== options.nonce) {\n      throw new OptionsVerificationError(\n        \"Signature nonce invalid.\",\n        payload.nonce,\n        options.nonce\n      );\n    }\n  }\n\n  if (options.maxAge) {\n    if (typeof payload.iat !== \"number\") {\n      throw new VerificationError(\"iat required when maxAge is specified\");\n    }\n\n    const maxAgeTimestamp = timespan(options.maxAge, payload.iat);\n    if (maxAgeTimestamp === undefined) {\n      throw new VerificationError(\n        '\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'\n      );\n    }\n    if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {\n      throw new TokenExpiredError(\"maxAge exceeded\", maxAgeTimestamp);\n    }\n  }\n\n  const valid = await jwsVerify(verifier, jwtString, decodedToken.payload.iss, options.sigEncoding);\n\n  if (!valid) {\n    throw new VerificationError(\"Invalid signature\");\n  }\n\n  const signature = decodedToken.signature;\n  if (options.complete)\n    return {\n      header: header,\n      payload: payload,\n      signature: signature,\n    };\n  else return payload;\n}\n","import { timespan } from \"./utils\";\nimport { signJws } from \"./jws\";\nimport { payloadSchema, signOptionsSchema } from \"./schemas\";\nimport { InvalidPayloadError, InvalidSignOptionsError } from \"./errors\";\n\nimport type { SignOptions, Payload, Header, Signer } from \"./types\";\n\nexport async function signJWT(\n  payload: Payload,\n  signer: Signer,\n  options: Partial<SignOptions> &\n    (Pick<SignOptions, \"header\"> | Pick<SignOptions, \"algorithm\">)\n): Promise<string> {\n  const payloadParseResult = payloadSchema.safeParse(payload);\n  if (!payloadParseResult.success) {\n    throw new InvalidPayloadError(\n      JSON.parse(payloadParseResult.error.message)[0].message\n    );\n  }\n\n  const optionsParseResult = signOptionsSchema.safeParse(options);\n  if (!optionsParseResult.success) {\n    throw new InvalidSignOptionsError(\n      JSON.parse(optionsParseResult.error.message)[0].message\n    );\n  }\n\n  // Default encoding values\n  const sigEncoding = options.sigEncoding || \"hex\";\n\n  let header: Header | undefined = options.header;\n\n  if (!header) {\n    if (!options.algorithm)\n      throw new InvalidSignOptionsError(\n        \"Either header or algorithm is required in options\"\n      );\n\n    header = {\n      alg: options.algorithm,\n    };\n  }\n\n  const timestamp = payload.iat || Math.floor(Date.now() / 1000);\n\n  if (options.noTimestamp) {\n    delete payload.iat;\n  } else {\n    payload.iat = timestamp;\n  }\n\n  if (options.expiresIn !== undefined) {\n    if (payload.exp !== undefined)\n      throw new InvalidSignOptionsError(\n        'Bad \"options.expiresIn\" option the payload already has an \"exp\" property.'\n      );\n    else payload.exp = timespan(options.expiresIn, timestamp);\n  }\n\n  if (options.notBefore !== undefined) {\n    if (payload.nbf !== undefined) {\n      throw new InvalidSignOptionsError(\n        'Bad \"options.notBefore\" option the payload already has an \"nbf\" property.'\n      );\n    } else payload.nbf = timespan(options.notBefore, timestamp);\n  }\n\n  return signJws(header, payload, signer, sigEncoding as BufferEncoding);\n}\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}